/* -*- Mode: C; c-basic-offset:4 ; -*- */
/*
 *  (C) 2018 by Argonne National Laboratory.
 *      See COPYRIGHT in top-level directory.
 *
 * Portions of this file are derived from the Sandia OpenSHMEM software
 * package. For license information, see the LICENSE file in the top level
 * directory of the Sandia OpenSHMEM distribution.
 *
 * Copyright 2011 Sandia Corporation. Under the terms of Contract
 * DE-AC04-94AL85000 with Sandia Corporation, the U.S.  Government
 * retains certain rights in this software.
 *
 * Copyright (c) 2023 Intel Corporation. All rights reserved.
 * This software is available to you under the BSD license.
 *
 * This file is automatically generated. DO NOT EDIT.
 */

#include <shmem.h>
#include "oshmpi_impl.h"
/* TPL_BLOCK_START */

void shmem_TYPENAME_wait_until(TYPE * ivar, int cmp, TYPE cmp_value)
{
    /* Does not return until ivar satisfies the condition implied by cmp and cmp_value. */
    OSHMPI_WAIT_UNTIL(ivar, cmp, cmp_value, TYPE, MPI_TYPE);
}

void shmem_TYPENAME_wait_until_all(TYPE * ivars, size_t nelems, const int *status, int cmp,
                                   TYPE cmp_value)
{
    size_t i = 0, num_ignored = 0;
    if (status) {
        for (i = 0; i < nelems; i++) {
            if (status[i]) num_ignored++;
        }
    }
    if (nelems == 0 || num_ignored == nelems) {
        OSHMPI_am_cb_progress();
        OSHMPI_progress_poll_mpi();
        return;
    }

    for (i = 0; i < nelems; i++) {
        if (status == NULL || !status[i]) {
            OSHMPI_WAIT_UNTIL(&ivars[i], cmp, cmp_value, TYPE, MPI_TYPE);
        }
    }

    /* FIXME? memory barrier or Win_sync instead? */
    OSHMPI_am_cb_progress();
    OSHMPI_progress_poll_mpi();
}

size_t shmem_TYPENAME_wait_until_any(TYPE * ivars, size_t nelems, const int *status, int cmp,
                                     TYPE cmp_value)
{
    size_t i = 0, found_idx = SIZE_MAX, num_ignored = 0;
    int cmpret = 0;
    if (status) {
        for (i = 0; i < nelems; i++) {
            if (status[i]) num_ignored++;
        }
    }

    if (nelems == 0 || num_ignored == nelems) {
        OSHMPI_am_cb_progress();
        OSHMPI_progress_poll_mpi();
        return SIZE_MAX;
    }

    OSHMPI_THREAD_ENTER_CS(&OSHMPI_global.rand_r_cs);
    size_t start_idx = (size_t) (rand_r(&OSHMPI_global.rand_r_cs_seed) / (RAND_MAX + 1.0) * (double) nelems);
    OSHMPI_THREAD_EXIT_CS(&OSHMPI_global.rand_r_cs);

    while (!cmpret) {
        for (i = 0; i < nelems; i++) {
            size_t idx = (i + start_idx) % nelems;
            if (status == NULL || !status[idx]) {
                OSHMPI_TEST(&ivars[idx], cmp, cmp_value, TYPE, MPI_TYPE, cmpret);
                if (cmpret) {
                    found_idx = idx;
                    break;
                }
            }
        }
        if (!cmpret) {
            OSHMPI_am_cb_progress();
            OSHMPI_progress_poll_mpi();
        }
    }
    // FIXME? memory barrier or Win_sync instead?
    OSHMPI_am_cb_progress();
    OSHMPI_progress_poll_mpi();
    return found_idx;
}

size_t shmem_TYPENAME_wait_until_some(TYPE * ivars, size_t nelems, size_t *indices,
                                      const int *status, int cmp, TYPE cmp_value)
{
    size_t i = 0, ncompleted = 0, num_ignored = 0;

    if (status) {
        for (i = 0; i < nelems; i++) {
            if (status[i]) num_ignored++;
        }
    }
    if (nelems == 0 || num_ignored == nelems) {
        OSHMPI_am_cb_progress();
        OSHMPI_progress_poll_mpi();
        return 0;
    }

    while (ncompleted == 0) {
        int cmpret = 0;
        for (i = 0; i < nelems; i++) {
            if (status == NULL || !status[i]) {
                OSHMPI_TEST(&ivars[i], cmp, cmp_value, TYPE, MPI_TYPE, cmpret);
                if (cmpret) {
                    indices[ncompleted++] = i;
                    cmpret = 0;
                }
            }
        }
        if (!cmpret) {
            OSHMPI_am_cb_progress();
            OSHMPI_progress_poll_mpi();
        }
    }
    // FIXME? memory barrier or Win_sync instead?
    OSHMPI_am_cb_progress();
    OSHMPI_progress_poll_mpi();
    return ncompleted;
}

void shmem_TYPENAME_wait_until_all_vector(TYPE * ivars, size_t nelems, const int *status, int cmp,
                                          TYPE * cmp_values)
{
    size_t i = 0, num_ignored = 0;
    if (status) {
        for (i = 0; i < nelems; i++) {
            if(status[i]) num_ignored++;
        }
    }
    if (nelems == 0 || num_ignored == nelems) {
        OSHMPI_am_cb_progress();
        OSHMPI_progress_poll_mpi();
        return;
    }
    for (i = 0; i < nelems; i++) {
        if (status == NULL || !status[i]) {
            OSHMPI_WAIT_UNTIL(&ivars[i], cmp, cmp_values[i], TYPE, MPI_TYPE);
        }
    }
    // FIXME? memory barrier or Win_sync instead?
    OSHMPI_am_cb_progress();
    OSHMPI_progress_poll_mpi();
}

size_t shmem_TYPENAME_wait_until_any_vector(TYPE * ivars, size_t nelems, const int *status, int cmp,
                                            TYPE * cmp_values)
{
    size_t i = 0, found_idx = SIZE_MAX, num_ignored = 0;
    int cmpret = 0;

    if (status) {
        for (i = 0; i < nelems; i++) {
            if (status[i]) num_ignored++;
        }
    }
    if (nelems == 0 || num_ignored == nelems) {
        OSHMPI_am_cb_progress();
        OSHMPI_progress_poll_mpi();
        return SIZE_MAX;
    }
    OSHMPI_THREAD_ENTER_CS(&OSHMPI_global.rand_r_cs);
    size_t start_idx = (size_t) (rand_r(&OSHMPI_global.rand_r_cs_seed) / (RAND_MAX + 1.0) * (double) nelems);
    OSHMPI_THREAD_EXIT_CS(&OSHMPI_global.rand_r_cs);

    while (!cmpret) {
        for (i = 0; i < nelems; i++) {
            size_t idx = (i + start_idx) % nelems;
            if (status == NULL || !status[idx]) {
                OSHMPI_TEST(&ivars[idx], cmp, cmp_values[idx], TYPE, MPI_TYPE, cmpret);
                if (cmpret) {
                    found_idx = idx;
                    break;
                }
            }
        }
        if (!cmpret) {
            OSHMPI_am_cb_progress();
            OSHMPI_progress_poll_mpi();
        }
    }
    // FIXME? memory barrier or Win_sync instead?
    OSHMPI_am_cb_progress();
    OSHMPI_progress_poll_mpi();
    return found_idx;
}

size_t shmem_TYPENAME_wait_until_some_vector(TYPE * ivars, size_t nelems, size_t *indices,
                                             const int *status, int cmp, TYPE * cmp_values)
{
    size_t i = 0, ncompleted = 0, num_ignored = 0;

    if (status) {
        for (i = 0; i < nelems; i++) {
            if (status[i]) num_ignored++;
        }
    }
    if (nelems == 0 || num_ignored == nelems) {
        OSHMPI_am_cb_progress();
        OSHMPI_progress_poll_mpi();
        return 0;
    }
    while (ncompleted == 0) {
        int cmpret = 0;
        for (i = 0; i < nelems; i++) {
            if (status == NULL || !status[i]) {
                OSHMPI_TEST(&ivars[i], cmp, cmp_values[i], TYPE, MPI_TYPE, cmpret);
                if (cmpret) {
                    indices[ncompleted++] = i;
                    cmpret = 0;
                }
            }
        }
        if (!cmpret) {
            OSHMPI_am_cb_progress();
            OSHMPI_progress_poll_mpi();
        }
    }
    // FIXME? memory barrier or Win_sync instead?
    OSHMPI_am_cb_progress();
    OSHMPI_progress_poll_mpi();
    return ncompleted;
}

int shmem_TYPENAME_test(TYPE * ivar, int cmp, TYPE cmp_value)
{
    int test_ret = 0;
    /* Returns 1 if the comparison evaluates to true; otherwise, returns 0. */
    OSHMPI_TEST(ivar, cmp, cmp_value, TYPE, MPI_TYPE, test_ret);
    return test_ret;
}

int shmem_TYPENAME_test_all(TYPE * ivars, size_t nelems, const int *status, int cmp,
                            TYPE cmp_value)
{
    size_t ncompleted = 0;
    size_t i = 0, num_ignored = 0;

    if (status) {
        for (i = 0; i < nelems; i++) {
            if (status[i]) num_ignored++;
        }
    }

    if (nelems == 0 || num_ignored == nelems) {
        OSHMPI_am_cb_progress();
        OSHMPI_progress_poll_mpi();
        // FIXME: just win_sync instead of fence?
        /* FIXME: something like this might be needed throughout the p2p sync APIs..
                 but only tests-sos 'cxx_shmem_test_all' seemed to require/cover this: */
        OSHMPI_ctx_fence(SHMEM_CTX_DEFAULT);
        return 1;
    }

    for (i = 0; i < nelems; i++) {
        if (status == NULL || !status[i]) {
            int cmpret;
            OSHMPI_TEST(ivars, cmp, cmp_value, TYPE, MPI_TYPE, cmpret);
            if (cmpret) ncompleted++;
        }
    }

    if (ncompleted == nelems) {
        /* FIXME: memory barrier instead? */
        OSHMPI_am_cb_progress();
        OSHMPI_progress_poll_mpi();
        OSHMPI_ctx_fence(SHMEM_CTX_DEFAULT);
        return 1;
    } else {
        OSHMPI_am_cb_progress();
        OSHMPI_progress_poll_mpi();
        //FIXME - something less heavy-handed than fence?
        OSHMPI_ctx_fence(SHMEM_CTX_DEFAULT);
        return 0;
    }
}

size_t shmem_TYPENAME_test_any(TYPE * ivars, size_t nelems, const int *status, int cmp,
                               TYPE cmp_value)
{
    size_t found_idx = SIZE_MAX, i = 0;
    OSHMPI_THREAD_ENTER_CS(&OSHMPI_global.rand_r_cs);
    size_t start_idx = (size_t) (rand_r(&OSHMPI_global.rand_r_cs_seed) / (RAND_MAX + 1.0) * (double) nelems);
    OSHMPI_THREAD_EXIT_CS(&OSHMPI_global.rand_r_cs);

    for (i = 0; i < nelems; i++) {
        int cmpret = 0;
        size_t idx = (i + start_idx) % nelems;
        if (status == NULL || !status[idx]) {
            OSHMPI_TEST(&ivars[idx], cmp, cmp_value, TYPE, MPI_TYPE, cmpret);
            if (cmpret) {
                found_idx = idx;
                break;
            }
        }
    }
    if (found_idx != SIZE_MAX) {
        /* FIXME: memory barrier or Win_sync instead? */
        OSHMPI_am_cb_progress();
        OSHMPI_progress_poll_mpi();
    } else {
        OSHMPI_am_cb_progress();
        OSHMPI_progress_poll_mpi();
    }
    return found_idx;
}

size_t shmem_TYPENAME_test_some(TYPE * ivars, size_t nelems, size_t *indices, const int *status,
                                int cmp, TYPE cmp_value)
{
    size_t i = 0, ncompleted = 0, num_ignored = 0;

    if (status) {
        for (i = 0; i < nelems; i++) {
            if (status[i]) num_ignored++;
        }
    }
    if (nelems == 0 || num_ignored == nelems) {
        OSHMPI_am_cb_progress();
        OSHMPI_progress_poll_mpi();
        return 0;
    }
    int cmpret = 0;
    for (i = 0; i < nelems; i++) {
        if (status == NULL || !status[i]) {
            OSHMPI_TEST(&ivars[i], cmp, cmp_value, TYPE, MPI_TYPE, cmpret);
            if (cmpret) {
                indices[ncompleted++] = i;
                cmpret = 0;
            }
        }
    }
    if (!cmpret) {
        OSHMPI_am_cb_progress();
        OSHMPI_progress_poll_mpi();
    }
    /* FIXME: memory barrier or Win_sync instead? */
    OSHMPI_am_cb_progress();
    OSHMPI_progress_poll_mpi();
    return ncompleted;
}

int shmem_TYPENAME_test_all_vector(TYPE * ivars, size_t nelems, const int *status, int cmp,
                                   TYPE * cmp_values)
{
    size_t ncompleted = 0;
    size_t i = 0, num_ignored = 0;

    if (status) {
        for (i = 0; i < nelems; i++) {
            if (status[i]) num_ignored++;
        }
    }
    if (nelems == 0 || num_ignored == nelems) {
        OSHMPI_am_cb_progress();
        OSHMPI_progress_poll_mpi();
        return 1;
    }
    for (i = 0; i < nelems; i++) {
        if (status == NULL || !status[i]) {
            int cmpret;
            OSHMPI_TEST(&ivars[i], cmp, cmp_values[i], TYPE, MPI_TYPE, cmpret);
            if (cmpret) ncompleted++;
        }
    }
    if (ncompleted == nelems) {
        /* FIXME: memory barrier or Win_sync instead? */
        OSHMPI_am_cb_progress();
        OSHMPI_progress_poll_mpi();
        return 1;
    } else {
        OSHMPI_am_cb_progress();
        OSHMPI_progress_poll_mpi();
        return 0;
    }
}

size_t shmem_TYPENAME_test_any_vector(TYPE * ivars, size_t nelems, const int *status, int cmp,
                                      TYPE * cmp_values)
{
    size_t found_idx = SIZE_MAX, i = 0;

    OSHMPI_THREAD_ENTER_CS(&OSHMPI_global.rand_r_cs);
    size_t start_idx = (size_t) (rand_r(&OSHMPI_global.rand_r_cs_seed) / (RAND_MAX + 1.0) * (double) nelems);
    OSHMPI_THREAD_EXIT_CS(&OSHMPI_global.rand_r_cs);

    for (i = 0; i < nelems; i++) {
        int cmpret = 0;
        size_t idx = (i + start_idx) % nelems;
        if (status == NULL || !status[idx]) {
            OSHMPI_TEST(&ivars[idx], cmp, cmp_values[idx], TYPE, MPI_TYPE, cmpret);
            if (cmpret) {
                found_idx = idx;
                break;
            }
        }
    }
    if (found_idx != SIZE_MAX) {
        /* FIXME: memory barrier or Win_sync here? */
    } else {
        OSHMPI_am_cb_progress();
        OSHMPI_progress_poll_mpi();
    }
    return found_idx;
}

size_t shmem_TYPENAME_test_some_vector(TYPE * ivars, size_t nelems, size_t *indices,
                                       const int *status, int cmp, TYPE * cmp_values)
{
    size_t i = 0, ncompleted = 0, num_ignored = 0;

    if (status) {
        for (i = 0; i < nelems; i++) {
            if (status[i]) num_ignored++;
        }
    }
    if (nelems == 0 || num_ignored == nelems) {
        OSHMPI_am_cb_progress();
        OSHMPI_progress_poll_mpi();
        return 0;
    }
    int cmpret = 0;
    for (i = 0; i < nelems; i++) {
        if (status == NULL || !status[i]) {
            OSHMPI_TEST(&ivars[i], cmp, cmp_values[i], TYPE, MPI_TYPE, cmpret);
            if (cmpret) {
                indices[ncompleted++] = i;
                cmpret = 0;
            }
        }
    }
    if (!cmpret) {
        OSHMPI_am_cb_progress();
        OSHMPI_progress_poll_mpi();
    }
    /* FIXME: memory barrier or Win_sync instead? */
    OSHMPI_am_cb_progress();
    OSHMPI_progress_poll_mpi();
    return ncompleted;
}
/* TPL_BLOCK_END */
